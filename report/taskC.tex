\documentclass[12pt,oneside,a4paper,slovak]{article}           

\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{pythonhighlight}
\usepackage[skip=0pt]{caption}
\usepackage{geometry}
\usepackage[final]{hyperref}
\usepackage[T1]{fontenc}                % slovencina
\usepackage[utf8]{inputenc}
\usepackage[slovak]{babel}

\geometry{top=2cm, bottom=2cm, left=2.5cm, right=2.5cm, headheight=0.6cm, headsep=0.3cm, footskip=1cm}

\renewcommand{\rmdefault}{phv} % Arial
\renewcommand{\sfdefault}{phv} % Arial
\renewcommand{\baselinestretch}{1}
\newcommand*{\vertbar}{\rule[0ex]{0.3pt}{1.5ex}}
\newcommand*{\horzbar}{\rule[0ex]{1.5ex}{0.3pt}}


\begin{document}   

\section*{Úloha C}
V tejto úlohe sa snažíme predikovať kvalitu vína, inšpirovaní prístupom Orleya Ashenfeltera k predikcii cien vína z Bordeaux.
\\
\\
Využívame dáta zo súboru A04wine.csv a aplikujeme modely L1 a L-inf z úlohy A, a využívame prístup rovnaký ako v B.
\\
Na implementáciu formulovaných LP úloh využívame opäť:
\begin{itemize}
	\item \pyth|pandas| - načítanie dát z .csv
	\item \pyth|numpy| - tvorenie matíc a vektorov
	\item \pyth|scipy.optimize| - implementovaný LP solver
\end{itemize}

Vyberieme z dát dané nezávislé premenné \pyth|x| a závislú premennú \pyth|y|

\begin{python}
y = data['Price']
x = data[['WinterRain','AGST', 'HarvestRain', 'Age', 'FrancePop']]
\end{python}
Zistíme počet premenných (plus 1 pre intercept)
\begin{python}
numberOfVariablesBeta = x.shape[1] + 1
\end{python}
Vytvoríme potrebné štruktúry pre zostavenie modelu normy \pyth|l1|
\begin{python}
c = np.array([0]*numberOfVariablesBeta + [1] * len(x.values)) # Objective function coefficients

ALeft = np.matrix([ [1] * len(x.values)]).transpose() # Coefficients for beta0
ARigth = np.matrix(x.values) # Coefficients for other independent variables beta
A = np.block([ALeft, ARigth]) # Concenate coefficients of variables into one matrix

I = np.identity(len(x.values)) # Identity matrix for intercept term
\end{python}
Naformulujeme problém a vyriešime pomocou \pyth|scipy.optimize.linprog|
\begin{python}
A_ub = np.block([[-A, -I], [A, -I]])
b_ub = np.concatenate([-y, y])

solve = linprog(c, A_ub, b_ub, bounds = [(None,None)]*numberOfVariablesBeta +[(0, None)])
\end{python}
Po vyriešení vyberieme z riešenia koeficienty
\begin{python}
betas = solve.x[:numberOfVariablesBeta]
\end{python}
Čo nám dá: 
\begin{equation*}
	\beta_0^{(1)} \approx -8.88014916e-01 ,~\beta_1^{(1)} \approx 1.57938208e-03 ,~\beta_2^{(1)} \approx 5.21297712e-01 
\end{equation*}
\begin{equation*}
~\beta_3^{(1)} \approx -4.51366553e-03 ,~\beta_4^{(1)} \approx 1.13002665e-02  ,~\beta_5^{(1)} \approx -2.21114476e-05
\end{equation*}
\\
Ďalej zostrojíme relevantné štruktúry a naformulujeme LP pre \pyth|l-inf| normu
\begin{python}
c_inf = np.array([0]*numberOfVariablesBeta + [1]) # Koeficienty cielovej funkcie
A_inf = np.block([ALeft, ARigth]) # Koeficienty pre nezavisle premenne pre l_inf normu
i_inf = np.array([ [1] * len(x.values)]).transpose() # Koeficienty pre intercept term pre l_inf normu

A_ub_inf = np.block([[-A_inf,-i_inf],[A_inf,-i_inf]])
b_ub_inf = np.concatenate([-y, y]) 
\end{python}
Vyriešime aj tento problém pomocou \pyth|scipy| pre \pyth|l-inf| normu a vyberieme beta-koeficienty
\begin{python}
solve_inf = linprog(c_inf, A_ub_inf, b_ub_inf, bounds=[(None,None)]*numberOfVariablesBeta+[(0,None)])
betas_inf = solve_inf.x[:numberOfVariablesBeta]
\end{python}
Po čom dostaneme:
\begin{equation*}
	\beta_0^{(2)} \approx  3.48412213e+00 ,~\beta_1^{(2)} \approx 8.33985438e-04 ,~\beta_2^{(2)} \approx 6.00266169e-01 
\end{equation*}
\begin{equation*}
~\beta_3^{(2)} \approx -3.34163738e-03 ,~\beta_4^{(2)} \approx -2.30363775e-02  ,~\beta_5^{(2)} \approx -1.19583600e-04
\end{equation*}




\end{document}
