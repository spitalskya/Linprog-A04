\documentclass[12pt,oneside,a4paper,slovak]{article}           

\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{pythonhighlight}
\usepackage[skip=0pt]{caption}
\usepackage{geometry}
\usepackage[final]{hyperref}
\usepackage[T1]{fontenc}                % slovencina
\usepackage[utf8]{inputenc}
\usepackage[slovak]{babel}

\geometry{top=2cm, bottom=2cm, left=2.5cm, right=2.5cm, headheight=0.6cm, headsep=0.3cm, footskip=1cm}

\renewcommand{\rmdefault}{phv} % Arial
\renewcommand{\sfdefault}{phv} % Arial
\renewcommand{\baselinestretch}{1}
\newcommand*{\vertbar}{\rule[0ex]{0.3pt}{1.5ex}}
\newcommand*{\horzbar}{\rule[0ex]{1.5ex}{0.3pt}}


\begin{document}   

\section*{Úloha B}


\subsubsection*{Prevedenie úlohy LP do tvaru pre \pyth|scipy.optimize.linprog|}

Metóda \pyth|linprog| z modulu \pyth|scipy.optimize| vyžaduje nasledujúci tvar úlohy LP:

\begin{align*}
	\text{min}~ &c^Tx\\
	&A_{ub}x \leq b_{ub} \\
	&A_{eq}x \leq b_{eq} \\
	&l \leq x \leq u & l,u \in (\mathbb{R}\cup \{\text{\pyth|None|\}})^n 
\end{align*}

Hodnota \pyth|None| vo vektoroch $l,~u$ značí neohraničenosť v danom smere. Upravme teda úlohy vyjadrené vyššie do predpísaného tvaru.

Pre $L^1$ regresiu:

\begin{align*}
	\text{min}~ &
	\left(
	\begin{array}{c|c}
		\mathbf{0}_{k+1}^T & \mathbf{1}_n^T
	\end{array}
	\right)
	\left(
	\begin{array}{c}
		\beta \\
		\hline
		t
	\end{array}
	\right) \\
	&\left(
	\begin{array}{c|c}
		-\mathbf{A} & -\mathbb{I}_n \\
		\hline
		\mathbf{A} & -\mathbb{I}_n
	\end{array}
	\right)
	\left(
	\begin{array}{c}
		\beta \\
		\hline
		t
	\end{array}
	\right)
	\leq
	\left(
	\begin{array}{c}
		-y \\
		\hline
		y
	\end{array}
	\right) \\
	&\text{\pyth|None|} \leq \beta_i \leq \text{\pyth|None|} &i = 0,1,\dots,k\\
	&0 \leq t_j \leq \text{\pyth|None|} &j = 1,\dots,n
\end{align*}

Pre $L^{\infty}$ regresiu:

\begin{align*}
	\text{min}~ &
	\left(
	\begin{array}{c|c}
		\mathbf{0}_{k+1}^T & 1
	\end{array}
	\right)
	\left(
	\begin{array}{c}
		\beta \\
		\hline
		\gamma
	\end{array}
	\right) \\
	&\left(
	\begin{array}{c|c}
		-\mathbf{A} & -\mathbf{1}_n \\
		\hline
		\mathbf{A} & -\mathbf{1}_n
	\end{array}
	\right)
	\left(
	\begin{array}{c}
		\beta \\
		\hline
		\gamma
	\end{array}
	\right)
	\leq
	\left(
	\begin{array}{c}
		-y \\
		\hline
		y
	\end{array}
	\right) \\
	&\text{\pyth|None|} \leq \beta_i \leq \text{\pyth|None|} &i = 0,1,\dots,k\\
	&0 \leq \gamma \leq \text{\pyth|None|}
\end{align*}

Úlohy v zdrojovom kóde sú implementované práve v tomto tvare.

\subsubsection*{Implementovanie regresných LP úloh}

Naimportovali sme knižnice; \pyth|numpy| na tvorenie matíc a vektorov, \pyth|scipy.optimize| na riešenie danej LP úlohy a \pyth|matplotlib| na vykresľovanie grafov.
\begin{python}
import numpy as np
from scipy.optimize import linprog
import pandas as pd
import matplotlib.pyplot as plt
\end{python}
Načítali dáta a rozdelili ich do premenných.
\begin{python}
data = np.load('data/A04plotregres.npz')
x = data['x']
y = data['y']
\end{python}
Začali sme s $L^1$ $(Manhattan)$ normou
\begin{python}
# l1 norm
c = np.array([0,0] + [1] * len(x))
A = np.matrix([[1] * len(x), x]).transpose()
I = np.identity(len(x))
A_ub = np.block([[-A,-I], [A,-I]])
b_ub = np.concatenate([-y, y])
solve = linprog(c, A_ub, b_ub)
beta0 = solve.x[0]
beta1 = solve.x[1]
values = [i*beta1 + beta0 for i in x]
\end{python}
\begin{python}
fig, ax = plt.subplots()
ax.plot(x, values, label = 'Manhattan')
ax.set_xlim([0, max(x) + 5])
ax.set_ylim([0, max(y) + 5]) 
\end{python}
Potom sme spočítali $L^\infty$ $(maximum)$ normu, a nasledovne ju tiež vykreslili do grafu.
\begin{python}
# l inf norm
c_inf = np.array([0,0,1])
A_inf = np.matrix([[1] * len(x), x]).transpose()
i_inf = np.array([[1] * len(x)]).transpose()
A_ub_inf = np.block([[-A_inf, -i_inf], [A_inf, -i_inf]])
b_ub_inf = np.concatenate([-y, y])
solve_inf = linprog(c_inf, A_ub_inf, b_ub_inf)
beta0_inf = solve_inf.x[0]
beta1_inf = solve_inf.x[1]
values_inf = [i * beta1_inf + beta0_inf for i in x]
\end{python}
\begin{python}
ax.plot(x, values_inf, label = 'infinity')
ax.plot(x,y, 'o')
ax.legend()
plt.show()
\end{python}



\end{document}
